{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "5379f461",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as  pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.model_selection import train_test_split\n",
    "import tensorflow as tf \n",
    "from keras.models import Sequential\n",
    "from keras.layers import Dense, Flatten, Dropout\n",
    "from keras.layers.convolutional import Conv2D, MaxPooling2D\n",
    "from keras.utils import to_categorical\n",
    "from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "89a81f14",
   "metadata": {},
   "source": [
    "## Uploading data set "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "92a7b1c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "x_train = pd.read_csv(\"csvTrainImages 60k x 784.csv\")\n",
    "y_train = pd.read_csv(\"csvTrainLabel 60k x 1.csv\")\n",
    "x_test = pd.read_csv(\"csvTestImages 10k x 784.csv\")\n",
    "y_test = pd.read_csv(\"csvTestLabel 10k x 1.csv\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2484626d",
   "metadata": {},
   "source": [
    "## Data Cleaning "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "e88a88c3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of missing values: 0        0\n",
      "0.1      0\n",
      "0.2      0\n",
      "0.3      0\n",
      "0.4      0\n",
      "        ..\n",
      "0.491    0\n",
      "0.492    0\n",
      "0.493    0\n",
      "0.494    0\n",
      "0.495    0\n",
      "Length: 784, dtype: int64\n"
     ]
    }
   ],
   "source": [
    "#check for missing values\n",
    "print(\"Number of missing values:\", np.isnan(x_train).sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "61cb93b5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of missing values: 0        0\n",
      "0.1      0\n",
      "0.2      0\n",
      "0.3      0\n",
      "0.4      0\n",
      "        ..\n",
      "0.491    0\n",
      "0.492    0\n",
      "0.493    0\n",
      "0.494    0\n",
      "0.495    0\n",
      "Length: 784, dtype: int64\n",
      "Number of missing values: 0    0\n",
      "dtype: int64\n",
      "Number of missing values: 0        0\n",
      "0.1      0\n",
      "0.2      0\n",
      "0.3      0\n",
      "0.4      0\n",
      "        ..\n",
      "0.543    0\n",
      "0.544    0\n",
      "0.545    0\n",
      "0.546    0\n",
      "0.547    0\n",
      "Length: 784, dtype: int64\n",
      "Number of missing values: 0    0\n",
      "dtype: int64\n"
     ]
    }
   ],
   "source": [
    "#check for missing values\n",
    "print(\"Number of missing values:\", np.isnan(x_train).sum())\n",
    "print(\"Number of missing values:\", np.isnan(y_train).sum())\n",
    "print(\"Number of missing values:\", np.isnan(x_test).sum())\n",
    "print(\"Number of missing values:\", np.isnan(y_test).sum())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "6fd67c2a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# concatenate to facilitate drop duplicates\n",
    "x = np.array(np.concatenate((x_train, x_test)), dtype='float64')\n",
    "y = np.array(np.concatenate((y_train, y_test)), dtype='int64')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "09d152c0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Flatten images into 1D array\n",
    "x_flat = x.reshape(x.shape[0], -1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "94762cd4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Find unique rows in flattened array\n",
    "unique_rows, indices = np.unique(x_flat, axis=0, return_index=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "fd869ff5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Duplicates found.\n"
     ]
    }
   ],
   "source": [
    "# Check for duplicates\n",
    "if len(unique_rows) == x_flat.shape[0]:\n",
    "    print(\"No duplicates found.\")\n",
    "else:\n",
    "    print(\"Duplicates found.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "a7892771",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Drop duplicates\n",
    "x_unique = x[indices]\n",
    "y_unique = y[indices]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "d2932393",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "X shape: (69998, 784)\n",
      "y shape: (69998, 1)\n"
     ]
    }
   ],
   "source": [
    "# Print the new shapes of the data\n",
    "print(\"X shape:\", x.shape)\n",
    "print(\"y shape:\", y.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "a79d1fe2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Reshape the figures\n",
    "x= x.reshape(-1, 28, 28, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "42df48c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Normalize the data\n",
    "x/= 255.0\n",
    "y= to_categorical(y)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7f254267",
   "metadata": {},
   "source": [
    "## Preparing data for our model "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "ca784cb7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# split the dataset into 70% for training and 30% for testing\n",
    "X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=42)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "59f0a91b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training set size: 48998\n",
      "Testing set size: 21000\n"
     ]
    }
   ],
   "source": [
    "# print the sizes of the training and testing sets\n",
    "print(\"Training set size:\", len(X_train))\n",
    "print(\"Testing set size:\", len(X_test))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "ca929da3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# We need to normalize the pictures to make it easy for the NN to make the calculation\n",
    "X_train = tf.keras.utils.normalize(X_train, axis = 1)\n",
    "X_test = tf.keras.utils.normalize(X_test, axis = 1)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "10053d93",
   "metadata": {},
   "source": [
    "# 1. Applying ANN "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "b76ced22",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/10\n",
      "1532/1532 [==============================] - 8s 4ms/step - loss: 0.1933 - accuracy: 0.9506 - val_loss: 0.1036 - val_accuracy: 0.9695\n",
      "Epoch 2/10\n",
      "1532/1532 [==============================] - 6s 4ms/step - loss: 0.0811 - accuracy: 0.9761 - val_loss: 0.0766 - val_accuracy: 0.9771\n",
      "Epoch 3/10\n",
      "1532/1532 [==============================] - 7s 4ms/step - loss: 0.0571 - accuracy: 0.9833 - val_loss: 0.0658 - val_accuracy: 0.9799\n",
      "Epoch 4/10\n",
      "1532/1532 [==============================] - 6s 4ms/step - loss: 0.0419 - accuracy: 0.9881 - val_loss: 0.0595 - val_accuracy: 0.9821\n",
      "Epoch 5/10\n",
      "1532/1532 [==============================] - 6s 4ms/step - loss: 0.0320 - accuracy: 0.9903 - val_loss: 0.0543 - val_accuracy: 0.9845\n",
      "Epoch 6/10\n",
      "1532/1532 [==============================] - 7s 5ms/step - loss: 0.0247 - accuracy: 0.9927 - val_loss: 0.0521 - val_accuracy: 0.9853\n",
      "Epoch 7/10\n",
      "1532/1532 [==============================] - 6s 4ms/step - loss: 0.0190 - accuracy: 0.9944 - val_loss: 0.0485 - val_accuracy: 0.9863\n",
      "Epoch 8/10\n",
      "1532/1532 [==============================] - 7s 4ms/step - loss: 0.0145 - accuracy: 0.9959 - val_loss: 0.0521 - val_accuracy: 0.9858\n",
      "Epoch 9/10\n",
      "1532/1532 [==============================] - 8s 5ms/step - loss: 0.0121 - accuracy: 0.9967 - val_loss: 0.0510 - val_accuracy: 0.9864\n",
      "Epoch 10/10\n",
      "1532/1532 [==============================] - 7s 5ms/step - loss: 0.0103 - accuracy: 0.9970 - val_loss: 0.0487 - val_accuracy: 0.9873\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<keras.callbacks.History at 0x1ccb5f32c40>"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Define the architecture of the ANN\n",
    "model = Sequential()\n",
    "model.add(Flatten(input_shape=(28, 28))) # Flatten the input image\n",
    "model.add(Dense(128, activation='relu')) # Add a fully connected hidden layer with 128 neurons and ReLU activation\n",
    "model.add(Dense(10, activation='softmax')) # Add a fully connected output layer with 10 neurons and softmax activation\n",
    "\n",
    "# Compile the model\n",
    "model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])\n",
    "\n",
    "# Train the model on the MNIST dataset\n",
    "model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "b9c75e05",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "657/657 [==============================] - 1s 2ms/step - loss: 0.0487 - accuracy: 0.9873\n",
      "0.987333357334137\n"
     ]
    }
   ],
   "source": [
    "loss, accuracy = model.evaluate(X_test, y_test)\n",
    "print(accuracy)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "fa5cffe8",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING:absl:Found untraced functions such as _update_step_xla while saving (showing 1 of 1). These functions will not be directly callable after loading.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INFO:tensorflow:Assets written to: handwritten.model\\assets\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO:tensorflow:Assets written to: handwritten.model\\assets\n"
     ]
    }
   ],
   "source": [
    "model.save(\"handwritten.model\");"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "7e3bf98c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# load the model that we saved \n",
    "model = tf.keras.models.load_model('handwritten.model')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "3132eac9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "657/657 [==============================] - 1s 2ms/step\n"
     ]
    }
   ],
   "source": [
    "predictions = model.predict([X_test])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "07017b98",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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7uI43MVxuIvjcFe2HYde98EEAED/kVVXQgCAvoUIAQDMECEAgBkiBAAwk1UReu+991RUVKQhQ4Zo8uTJOnz4sPWSHqvKykr5fL6kLRQKWS8r4w4dOqT58+crEonI5/Np9+7dSc8751RZWalIJKKhQ4dq9uzZOnnypM1iM+hBx2Hp0qXdzo/p06fbLDZDqqqqNHXqVAUCAeXn52vBggU6ffp00j794Xx4mOOQLedD1kRo586dWr16tdatW6fGxka98MILKisr0/nz562X9liNHz9ely5dSmwnTpywXlLGdXZ2atKkSaquru7x+U2bNmnz5s2qrq7W0aNHFQqFNHfu3D53H8IHHQdJmjdvXtL5sW/fvse4wsyrq6vTihUrdOTIEdXU1Kirq0ulpaXq7OxM7NMfzoeHOQ5SlpwPLks8++yz7s0330x6bNy4ce7nP/+50Yoev/Xr17tJkyZZL8OUJPfRRx8lvr5z544LhUJu48aNicdu3LjhgsGg++1vf2uwwsfjm8fBOefKy8vdSy+9ZLIeK21tbU6Sq6urc8713/Phm8fBuew5H7LiSujmzZtqaGhQaWlp0uOlpaWqr683WpWNpqYmRSIRFRUV6dVXX9XZs2etl2SqublZra2tSeeG3+/XrFmz+t25IUm1tbXKz89XcXGxli1bpra2NuslZVQ0GpUk5eXlSeq/58M3j8M92XA+ZEWELl++rNu3b6ugoCDp8YKCArW2thqt6vGbNm2atm/frk8//VTvv/++WltbVVJSovb2duulmbn3v39/PzckqaysTB988IEOHDigd955R0ePHtWcOXMUj8etl5YRzjlVVFTo+eef14QJEyT1z/Ohp+MgZc/50Ovuon0/3/ynHZxz3R7ry8rKyhL/PXHiRM2YMUNjxozRtm3bVFFRYbgye/393JCkxYsXJ/57woQJmjJligoLC7V3714tXLjQcGWZsXLlSn355Zf67LPPuj3Xn86HbzsO2XI+ZMWV0PDhw5WTk9PtbzJtbW3d/sbTnwwbNkwTJ05UU1OT9VLM3Pt0IOdGd+FwWIWFhX3y/Fi1apX27NmjgwcPJv3TL/3tfPi249CT3no+ZEWEBg8erMmTJ6umpibp8ZqaGpWUlBityl48HtepU6cUDoetl2KmqKhIoVAo6dy4efOm6urq+vW5IUnt7e1qaWnpU+eHc04rV67Url27dODAARUVFSU931/Ohwcdh5702vPB8EMRnnz44Ydu0KBB7ve//737xz/+4VavXu2GDRvmzp07Z720x+att95ytbW17uzZs+7IkSPuJz/5iQsEAn3+GHR0dLjGxkbX2NjoJLnNmze7xsZG99VXXznnnNu4caMLBoNu165d7sSJE+61115z4XDYxWIx45Wn1/2OQ0dHh3vrrbdcfX29a25udgcPHnQzZsxwTz31VJ86Dj/72c9cMBh0tbW17tKlS4nt2rVriX36w/nwoOOQTedD1kTIOed+85vfuMLCQjd48GD3zDPPJH0csT9YvHixC4fDbtCgQS4SibiFCxe6kydPWi8r4w4ePOgkddvKy8udc3c/lrt+/XoXCoWc3+93M2fOdCdOnLBddAbc7zhcu3bNlZaWuhEjRrhBgwa50aNHu/Lycnf+/HnrZadVT79/SW7r1q2JffrD+fCg45BN5wP/lAMAwExWvCcEAOibiBAAwAwRAgCYIUIAADNECABghggBAMwQIQCAGSIEADBDhAAAZogQAMAMEQIAmCFCAAAz/wNUXvJlwdywfgAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.imshow(X_test[5485], cmap='gray')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "bb5d0784",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "8\n"
     ]
    }
   ],
   "source": [
    "print(np.argmax(predictions[5485]))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "144f6530",
   "metadata": {},
   "source": [
    "# 2. Applying CNN "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "dc9dcad4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the architecture of the CNN\n",
    "model = Sequential()\n",
    "model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))\n",
    "model.add(MaxPooling2D((2, 2)))\n",
    "model.add(Conv2D(64, (3, 3), activation='relu'))\n",
    "model.add(MaxPooling2D((2, 2)))\n",
    "model.add(Conv2D(64, (3, 3), activation='relu'))\n",
    "model.add(Flatten())\n",
    "model.add(Dense(64, activation='relu'))\n",
    "model.add(Dense(10, activation='softmax'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "0d5a0157",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Compile the model\n",
    "model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "1f82870d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/10\n",
      "1532/1532 [==============================] - 30s 19ms/step - loss: 0.1186 - accuracy: 0.9647 - val_loss: 0.0416 - val_accuracy: 0.9878\n",
      "Epoch 2/10\n",
      "1532/1532 [==============================] - 29s 19ms/step - loss: 0.0349 - accuracy: 0.9892 - val_loss: 0.0268 - val_accuracy: 0.9916\n",
      "Epoch 3/10\n",
      "1532/1532 [==============================] - 30s 19ms/step - loss: 0.0259 - accuracy: 0.9920 - val_loss: 0.0277 - val_accuracy: 0.9924\n",
      "Epoch 4/10\n",
      "1532/1532 [==============================] - 31s 20ms/step - loss: 0.0219 - accuracy: 0.9933 - val_loss: 0.0256 - val_accuracy: 0.9923\n",
      "Epoch 5/10\n",
      "1532/1532 [==============================] - 28s 19ms/step - loss: 0.0188 - accuracy: 0.9943 - val_loss: 0.0296 - val_accuracy: 0.9921\n",
      "Epoch 6/10\n",
      "1532/1532 [==============================] - 28s 19ms/step - loss: 0.0151 - accuracy: 0.9951 - val_loss: 0.0367 - val_accuracy: 0.9896\n",
      "Epoch 7/10\n",
      "1532/1532 [==============================] - 29s 19ms/step - loss: 0.0147 - accuracy: 0.9955 - val_loss: 0.0247 - val_accuracy: 0.9939\n",
      "Epoch 8/10\n",
      "1532/1532 [==============================] - 30s 20ms/step - loss: 0.0118 - accuracy: 0.9961 - val_loss: 0.0258 - val_accuracy: 0.9934\n",
      "Epoch 9/10\n",
      "1532/1532 [==============================] - 31s 20ms/step - loss: 0.0104 - accuracy: 0.9966 - val_loss: 0.0275 - val_accuracy: 0.9931\n",
      "Epoch 10/10\n",
      "1532/1532 [==============================] - 30s 20ms/step - loss: 0.0102 - accuracy: 0.9970 - val_loss: 0.0212 - val_accuracy: 0.9943\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<keras.callbacks.History at 0x1ccb633bf70>"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Train the model\n",
    "model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "26628c02",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "657/657 [==============================] - 4s 6ms/step - loss: 0.0212 - accuracy: 0.9943\n",
      "Test accuracy: 0.9943333268165588\n"
     ]
    }
   ],
   "source": [
    "# Evaluate the model on the testing dataset\n",
    "test_loss, test_acc = model.evaluate(X_test, y_test)\n",
    "print('Test accuracy:', test_acc)\n",
    "\n",
    "# Save the model\n",
    "model.save('arabic_digits_cnn_model.h5')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "8ff4a9e2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# load the model that we saved \n",
    "model = tf.keras.models.load_model('arabic_digits_cnn_model.h5')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "09095c6d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "657/657 [==============================] - 4s 6ms/step\n"
     ]
    }
   ],
   "source": [
    "# Evaluate the model on the test data\n",
    "pred = model.predict([X_test])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "a60ba100",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "#plot a figure from x test\n",
    "plt.imshow(X_test[188], cmap='gray')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "808cad3e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5\n"
     ]
    }
   ],
   "source": [
    "print(np.argmax(pred[188]))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f02cf509",
   "metadata": {},
   "source": [
    "# Calculate accuracy, precision, recall and f- score for ANN "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "5ed59008",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "657/657 [==============================] - 2s 2ms/step\n"
     ]
    }
   ],
   "source": [
    "# Load the ANN model and make predictions on the testing dataset\n",
    "ann_model = tf.keras.models.load_model('handwritten.model')\n",
    "ann_pred = ann_model.predict(X_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "78a5bbb3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Convert the predictions to classes\n",
    "ann_pred_classes = np.argmax(ann_pred, axis=1)\n",
    "y_test_classes = np.argmax(y_test, axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "0580620f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate the evaluation metrics for the ANN\n",
    "ann_accuracy = accuracy_score(y_test_classes, ann_pred_classes)\n",
    "ann_precision = precision_score(y_test_classes, ann_pred_classes, average='weighted')\n",
    "ann_recall = recall_score(y_test_classes, ann_pred_classes, average='weighted')\n",
    "ann_f1 = f1_score(y_test_classes, ann_pred_classes, average='weighted')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "6b8fc5e8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ANN Accuracy: 0.9873333333333333\n",
      "ANN Precision: 0.9873481578450443\n",
      "ANN Recall: 0.9873333333333333\n",
      "ANN F1-Score: 0.9873334570535443\n"
     ]
    }
   ],
   "source": [
    "print(\"ANN Accuracy:\", ann_accuracy)\n",
    "print(\"ANN Precision:\", ann_precision)\n",
    "print(\"ANN Recall:\", ann_recall)\n",
    "print(\"ANN F1-Score:\", ann_f1)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7b17928a",
   "metadata": {},
   "source": [
    "# Calculate accuracy, precision, recall and f- score for CNN "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "dcfdb1c6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "657/657 [==============================] - 4s 6ms/step\n"
     ]
    }
   ],
   "source": [
    "# Load the CNN model and make predictions on the testing dataset\n",
    "cnn_model = tf.keras.models.load_model('arabic_digits_cnn_model.h5')\n",
    "cnn_pred = cnn_model.predict(X_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "5b72a225",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Convert the predictions to classes\n",
    "cnn_pred_classes = np.argmax(cnn_pred, axis=1)\n",
    "y_test_classes = np.argmax(y_test, axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "73f09f4a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate the evaluation metrics for the CNN\n",
    "cnn_accuracy = accuracy_score(y_test_classes, cnn_pred_classes)\n",
    "cnn_precision = precision_score(y_test_classes, cnn_pred_classes, average='weighted')\n",
    "cnn_recall = recall_score(y_test_classes, cnn_pred_classes, average='weighted')\n",
    "cnn_f1 = f1_score(y_test_classes, cnn_pred_classes, average='weighted')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "87f87b22",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CNN Accuracy: 0.9943333333333333\n",
      "CNN Precision: 0.9943401033963067\n",
      "CNN Recall: 0.9943333333333333\n",
      "CNN F1-Score: 0.9943285134872311\n"
     ]
    }
   ],
   "source": [
    "# Print the evaluation metrics for the CNN algorithm\n",
    "print(\"CNN Accuracy:\", cnn_accuracy)\n",
    "print(\"CNN Precision:\", cnn_precision)\n",
    "print(\"CNN Recall:\", cnn_recall)\n",
    "print(\"CNN F1-Score:\", cnn_f1)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d3a2617d",
   "metadata": {},
   "source": [
    "# Compare the result between ANN and CNN "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "78db63a8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The CNN algorithm has the best accuracy.\n",
      "The CNN algorithm has thebest precision.\n",
      "The CNN algorithm has the best recall.\n",
      "The CNN algorithm has the best F1-Score.\n"
     ]
    }
   ],
   "source": [
    "if ann_accuracy > cnn_accuracy:\n",
    "    print(\"The ANN algorithm has the best accuracy.\")\n",
    "else:\n",
    "    print(\"The CNN algorithm has the best accuracy.\")\n",
    "\n",
    "if ann_precision > cnn_precision:\n",
    "    print(\"The ANN algorithm has the best precision.\")\n",
    "else:\n",
    "    print(\"The CNN algorithm has thebest precision.\")\n",
    "\n",
    "if ann_recall > cnn_recall:\n",
    "    print(\"The ANN algorithm has the best recall.\")\n",
    "else:\n",
    "    print(\"The CNN algorithm has the best recall.\")\n",
    "\n",
    "if ann_f1 > cnn_f1:\n",
    "    print(\"The ANN algorithm has the best F1-Score.\")\n",
    "else:\n",
    "    print(\"The CNN algorithm has the best F1-Score.\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
